*[English](README.md) ∙ [日本語](README-ja.md) ∙ [简体中文](README-zh-Hans.md) ∙ [繁體中文](README-zh-TW.md) | [العَرَبِيَّة‎](https://github.com/donnemartin/system-design-primer/issues/170) ∙ [বাংলা](https://github.com/donnemartin/system-design-primer/issues/220) ∙ [Português do Brasil](https://github.com/donnemartin/system-design-primer/issues/40) ∙ [Deutsch](https://github.com/donnemartin/system-design-primer/issues/186) ∙ [ελληνικά](https://github.com/donnemartin/system-design-primer/issues/130) ∙ [עברית](https://github.com/donnemartin/system-design-primer/issues/272) ∙ [Italiano](https://github.com/donnemartin/system-design-primer/issues/104) ∙ [한국어](https://github.com/donnemartin/system-design-primer/issues/102) ∙ [فارسی](https://github.com/donnemartin/system-design-primer/issues/110) ∙ [Polski](https://github.com/donnemartin/system-design-primer/issues/68) ∙ [русский язык](https://github.com/donnemartin/system-design-primer/issues/87) ∙ [Español](https://github.com/donnemartin/system-design-primer/issues/136) ∙ [ภาษาไทย](https://github.com/donnemartin/system-design-primer/issues/187) ∙ [Türkçe](https://github.com/donnemartin/system-design-primer/issues/39) ∙ [tiếng Việt](https://github.com/donnemartin/system-design-primer/issues/127) ∙ [Français](https://github.com/donnemartin/system-design-primer/issues/250) | [Add Translation](https://github.com/donnemartin/system-design-primer/issues/28)*

**Допоможи з [перекладом](TRANSLATIONS.md) цього посібника!**

# Вступ до проектування програмних систем

<p align="center">
  <img src="images/jj3A5N8.png">
  <br/>
</p>

## Мета курсу

> Навчитися проектувати масштабовані системи.
>
> Підготуватися до співбесід із проектування програмних систем.

### Проектування масштабованих систем

Вивчення проектування масштабованих систем допоможе Вам стати кращим програмним інженером.

Проектування програмних систем - це дуже широка галузь знань. В інтернеті існує **величезна кількість ресурсів** по основах проектування.

Цей репозиторій є систематизованим набором ресурсів, що допоможуть Вам навчитися конструювати масштабовані системи.

### Вчіться зі спільнотою відкритого коду

Проект є відкритим і постійно оновлюється.

[Допомога](#contributing) завжди вітається!

### Підготовка до співбесід з проектування програмних систем

Крім написання програмного коду, проектування систем є **невід'ємною частиною циклу технічних співбесід** в більшості технічних компаній.

**Практикуйтеся на типових задачах по проектуванню, які запитують на співбесідах** та **порівнюйте** Ваші рішення із **запропонованими**: обговореннями, кодом та діаграмами.

Додаткові розділи для підготовки до співбесіди:

* [Study guide](#study-guide)
* [Як підходити до питань з системного проектування на співбесідах](#Як-підходити-до-питань-з-системного-проектування-на-співбесідах)
* [Задачі по проектуванню на співбесідах, **з рішеннями**](#Задачі-по-проектуванню-на-співбесідах-з-рішеннями)
* [Задачі по об’єктно-орієнтованому проектуванню на співбесідах, **з рішеннями**](#Задачі-по-обєктно-орієнтованому-проектуванню-на-співбесідах-з-рішеннями)
* [Додаткові задачі по проектуванню на співбесідах](#Додаткові-задачі-по-проектуванню-на-співбесідах)

## Картки Anki

<p align="center">
  <img src="images/zdCAkB3.png">
  <br/>
</p>

Використовуйте [Anki flashcard decks](https://apps.ankiweb.net/) для інтервального повторення що допоможе вам запамятати ключові концепції проектування систем.

* [Проектування систем](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design.apkg)
* [Вправи з проектування систем](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/System%20Design%20Exercises.apkg)
* [Вправи з об’єктно-орієнтованого проектування](https://github.com/donnemartin/system-design-primer/tree/master/resources/flash_cards/OO%20Design.apkg)

Чудово підходить для використання в дорозі.

### Ресурси по програмуванню: Інтерактивні завдання

Шукаєте ресурси які допоможуть вам підготуватися до [**Coding Interview**](https://github.com/donnemartin/interactive-coding-challenges)?

<p align="center">
  <img src="images/b4YtAEN.png">
  <br/>
</p>

Подивіться на наш дочірній репозиторій: [**Interactive Coding Challenges**](https://github.com/donnemartin/interactive-coding-challenges), який містить додатковий набір Anki карт:

* [Програмування](https://github.com/donnemartin/interactive-coding-challenges/tree/master/anki_cards/Coding.apkg)

## Підтримка

> Вчіться у спільноти.

Не соромся відправляти запити на виправлення щоб допомогти:

* Виправлення помилок
* Покращення секцій
* Додавання нових секцій
* [Перекладайте](https://github.com/donnemartin/system-design-primer/issues/28)

Матеріал який потрібно доопрацювати розміщається в розділі [В розробці](#В-розробці).

Ознайомтесь з [Інструкцією щодо допомоги](CONTRIBUTING.md).

## Перелік тем з системного дизайну

> Узагальнення з різноманітних тем системного дизайну включаючи їх переваги та недоліки.   **Будь-яке рішення є компромісом**.
>
> Кожна секція містить посилання на ресурси для поглибленого вивчення.

<p align="center">
  <img src="images/jrUBAF7.png">
  <br/>
</p>

* [System design topics: start here](#system-design-topics-start-here)
  * [Step 1: Review the scalability video lecture](#step-1-review-the-scalability-video-lecture)
  * [Step 2: Review the scalability article](#step-2-review-the-scalability-article)
  * [Next steps](#next-steps)
* [Performance vs scalability](#performance-vs-scalability)
* [Latency vs throughput](#latency-vs-throughput)
* [Availability vs consistency](#availability-vs-consistency)
  * [CAP theorem](#cap-theorem)
    * [CP - consistency and partition tolerance](#cp---consistency-and-partition-tolerance)
    * [AP - availability and partition tolerance](#ap---availability-and-partition-tolerance)
* [Consistency patterns](#consistency-patterns)
  * [Weak consistency](#weak-consistency)
  * [Eventual consistency](#eventual-consistency)
  * [Strong consistency](#strong-consistency)
* [Availability patterns](#availability-patterns)
  * [Fail-over](#fail-over)
  * [Replication](#replication)
  * [Availability in numbers](#availability-in-numbers)
* [Domain name system](#domain-name-system)
* [Content delivery network](#content-delivery-network)
  * [Push CDNs](#push-cdns)
  * [Pull CDNs](#pull-cdns)
* [Load balancer](#load-balancer)
  * [Active-passive](#active-passive)
  * [Active-active](#active-active)
  * [Layer 4 load balancing](#layer-4-load-balancing)
  * [Layer 7 load balancing](#layer-7-load-balancing)
  * [Horizontal scaling](#horizontal-scaling)
* [Reverse proxy (web server)](#reverse-proxy-web-server)
  * [Load balancer vs reverse proxy](#load-balancer-vs-reverse-proxy)
* [Application layer](#application-layer)
  * [Microservices](#microservices)
  * [Service discovery](#service-discovery)
* [База даних](#база-даних)
  * [Система управління реляційними базами даних (RDBMS)](#Система-управління-реляційними-базами-даних-rdbms)
    * [Master-slave replication](#master-slave-replication)
    * [Master-master replication](#master-master-replication)
    * [Федерація](#федерація)
    * [Шардінг](#шардінг)
    * [Денормалізація](#денормалізація)
    * [SQL tuning](#sql-tuning)
  * [NoSQL](#nosql)
    * [Key-value store](#key-value-store)
    * [Document store](#document-store)
    * [Wide column store](#wide-column-store)
    * [Graph Database](#graph-database)
  * [SQL or NoSQL](#sql-or-nosql)
* [Cache](#cache)
  * [Client caching](#client-caching)
  * [CDN caching](#cdn-caching)
  * [Web server caching](#web-server-caching)
  * [Database caching](#database-caching)
  * [Application caching](#application-caching)
  * [Caching at the database query level](#caching-at-the-database-query-level)
  * [Caching at the object level](#caching-at-the-object-level)
  * [When to update the cache](#when-to-update-the-cache)
    * [Cache-aside](#cache-aside)
    * [Write-through](#write-through)
    * [Write-behind (write-back)](#write-behind-write-back)
    * [Refresh-ahead](#refresh-ahead)
* [Asynchronism](#asynchronism)
  * [Message queues](#message-queues)
  * [Task queues](#task-queues)
  * [Back pressure](#back-pressure)
* [Communication](#communication)
  * [Transmission control protocol (TCP)](#transmission-control-protocol-tcp)
  * [User datagram protocol (UDP)](#user-datagram-protocol-udp)
  * [Remote procedure call (RPC)](#remote-procedure-call-rpc)
  * [Representational state transfer (REST)](#representational-state-transfer-rest)
* [Security](#security)
* [Appendix](#appendix)
  * [Powers of two table](#powers-of-two-table)
  * [Latency numbers every programmer should know](#latency-numbers-every-programmer-should-know)
  * [Additional system design interview questions](#additional-system-design-interview-questions)
  * [Real world architectures](#real-world-architectures)
  * [Company architectures](#company-architectures)
  * [Company engineering blogs](#company-engineering-blogs)
* [В розробці](#В-розробці)
* [Credits](#credits)
* [Contact info](#contact-info)
* [License](#license)
* 
## Навчальний план

> Запропоновані теми для ознайомлення базуються на вашому графіку співбесід (короткому, середньому, довгому).

![Imgur](images/OfVllex.png)

**Питання: Чи повинен я знати все описане тут для співбесіди?**

**Відповідь: Ні, не повинен**.

Питання на вашій співбесіді залежатимуть від:

* Вашого досвіду
* Вашої технічної кваліфікації
* Позиції, на яку ви співбесідуєтесь
* Компанії, в якій ви співбесідуєтесь 
* Вашої вдачі

Зазвичай очікується, що кандидати з більшим досвідом знають більше про системне проектування. Архітектори або лідери команд мали б знати більше ніж окремі виконавці. Ймовірно саме тому найкращі технологічні компанії мають один або кілька раундів співбесід по проектуванню систем.

Одразу розпочинайте з кількох тем. Це допоможе вам дізнатись трішки про різноманітні ключові теми системного проектування. Коректуйте цей посібник залежно від вашого часу, досвіду, позиції, на яку ви співбесідуєтесь, і компанії, в яку ви співбесідуєтесь.

* **При короткому відрізку часу** - Вашою ціллю є осягнути **вширину** теми системного проектування. Практикуйтеся, розв'язуючи **деякі** питання зі співбесід.
* **При середньому відрізку часу** - Вашою ціллю є осягнути **вширину** і **трішки вглибину** теми системного проектування. Практикуйтеся, розв'язуючи **багато** питань зі співбесід.
* **При довгому відрізку часу** - Вашою ціллю є осягнути **вширину** і **більше вглибину** теми системного проектування. Практикуйтеся, розв'язуючи **більшість** питань зі співбесід.

|                                                                                                                                                                 | Короткий | Середній | Довгий |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|---|---|---|
| Прочитайте [Перелік тем з системного дизайну](#Перелік-тем-з-системного-дизайну), щоб отримати широке розуміння того, як працюють системи                       | :+1: | :+1: | :+1: |
| Прочитайте кілька статей в [Company engineering blogs](#company-engineering-blogs) компаній, де ви проходите співбесіду                                         | :+1: | :+1: | :+1: |
| Прочитайте кілька [Real world architectures](#real-world-architectures)                                                                                         | :+1: | :+1: | :+1: |
| Перегляньте [Як підходити до питань з системного проектування на співбесідах](#Як-підходити-до-питань-з-системного-проектування-на-співбесідах)                 | :+1: | :+1: | :+1: |
| Опрацюйте [Задачі по проектуванню на співбесідах, з рішеннями](#Задачі-по-проектуванню-на-співбесідах-з-рішеннями)                                              | Кілька | Багато | Майже всі |
| Опрацюйте [Задачі по об’єктно-орієнтованому проектуванню на співбесідах, з рішеннями](#Задачі-по-обєктно-орієнтованому-проектуванню-на-співбесідах-з-рішеннями) | Кілька | Багато | Майже всі |
| Перегляньте [Додаткові задачі по проектуванню на співбесідах](#Додаткові-задачі-по-проектуванню-на-співбесідах)                                                 | Кілька | Багато | Майже всі |

## Як підходити до питань з системного проектування на співбесідах

> Як вирішувати питання з системного проектування на співбесідах.

Співбесіда з системного проектування є **відкритою бесідою**.  Очікується, що ви будете її вести.

Ви можете використовувати наступні кроки, щоб вести дискусію.  Щоб закріпити цей процес, опрацюйте секцію [Задачі по проектуванню на співбесідах, з рішеннями](#Задачі-по-проектуванню-на-співбесідах-з-рішеннями) використовуючи наступні кроки.

### Крок 1: Окресліть сценарії/варіанти використання, обмеження та припущення

Зберіть вимоги та оцініть обсяг задачі.  Задавайте питання для вияснення сценаріїв/варіантів використання та обмежень. Обговорюйте припущення.

* Хто буде це використовувати?
* Як це будуть використовувати?
* Скільки буде користувачів?
* Що система буде робити?
* Що є вхідними та вихідними даними для системи?
* Скільки даних очікується обробляти?
* Скільки запитів в секунду очікується?
* Яким є очікуване співвідношення зчитувань до записів?

### Крок 2: Створіть високорівневу архітектуру

Виокреміть високорівневу архітектуру зі всіма важливими компонентами.

* Окресліть ключові компоненти та їх зв'язки
* Обгрунтуйте ваші ідеї

### Крок 3: Спроектуйте ключові компоненти

Заглибтесь в деталі кожного ключового компоненту. Наприклад, якщо вас попросили [спроектувати сервіс скорочення URL](solutions/system_design/pastebin/README.md), обговоріть:

* Генерацію і зберігання хешу повного url
    * [MD5](solutions/system_design/pastebin/README.md) і [Base62](solutions/system_design/pastebin/README.md)
    * Хеш-колізії
    * SQL чи NoSQL
    * Схему бази даних
* Перехід з хешованого url до повного url
    * Пошук в базі даних
* API і об'єктно-орієнтовану архітектуру

### Крок 4: Зробіть архітектуру масштабованою

Визначте та вирішіть вузькі місця, враховуючи задані обмеження. Наприклад, чи потрібні вам наступні речі для вирішення проблем масштабування?

* Балансувальник навантаження(Load balancer)
* Горизонтальне масштабування(Horizontal scaling)
* Кешування(Caching)
* Шардинг бази даних(Database sharding)

Обговорюйте потенційні рішення та компроміси. Всі рішення є компромісами. Вирішуйте слабкі місця, використовуючи [принципи проектування масштабованої системи](#index-of-system-design-topics).

### Попередні розрахунки

Вас можуть попросити здійснити деякі грубі розрахунки. Звертайтесь [Appendix](#appendix) до наступних джерел:

* [Use back of the envelope calculations](http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html)
* [Powers of two table](#powers-of-two-table)
* [Latency numbers every programmer should know](#latency-numbers-every-programmer-should-know)

### Джерело(а) і додаткові матеріали

Ознайомтесь з наступними посиланнями, щоб краще знати на що очікувати:

* [How to ace a systems design interview](https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/)
* [The system design interview](http://www.hiredintech.com/system-design)
* [Intro to Architecture and Systems Design Interviews](https://www.youtube.com/watch?v=ZgdS0EUmn70)

## Задачі по проектуванню на співбесідах, з рішеннями

> Common system design interview questions with sample discussions, code, and diagrams.
>
> Solutions linked to content in the `solutions/` folder.

| Question | |
|---|---|
| Design Pastebin.com (or Bit.ly) | [Solution](solutions/system_design/pastebin/README.md) |
| Design the Twitter timeline and search (or Facebook feed and search) | [Solution](solutions/system_design/twitter/README.md) |
| Design a web crawler | [Solution](solutions/system_design/web_crawler/README.md) |
| Design Mint.com | [Solution](solutions/system_design/mint/README.md) |
| Design the data structures for a social network | [Solution](solutions/system_design/social_graph/README.md) |
| Design a key-value store for a search engine | [Solution](solutions/system_design/query_cache/README.md) |
| Design Amazon's sales ranking by category feature | [Solution](solutions/system_design/sales_rank/README.md) |
| Design a system that scales to millions of users on AWS | [Solution](solutions/system_design/scaling_aws/README.md) |
| Add a system design question | [Contribute](#contributing) |

### Design Pastebin.com (or Bit.ly)

[View exercise and solution](solutions/system_design/pastebin/README.md)

![Imgur](http://i.imgur.com/4edXG0T.png)

### Design the Twitter timeline and search (or Facebook feed and search)

[View exercise and solution](solutions/system_design/twitter/README.md)

![Imgur](http://i.imgur.com/jrUBAF7.png)

### Design a web crawler

[View exercise and solution](solutions/system_design/web_crawler/README.md)

![Imgur](http://i.imgur.com/bWxPtQA.png)

### Design Mint.com

[View exercise and solution](solutions/system_design/mint/README.md)

![Imgur](http://i.imgur.com/V5q57vU.png)

### Design the data structures for a social network

[View exercise and solution](solutions/system_design/social_graph/README.md)

![Imgur](http://i.imgur.com/cdCv5g7.png)

### Design a key-value store for a search engine

[View exercise and solution](solutions/system_design/query_cache/README.md)

![Imgur](http://i.imgur.com/4j99mhe.png)

### Design Amazon's sales ranking by category feature

[View exercise and solution](solutions/system_design/sales_rank/README.md)

![Imgur](http://i.imgur.com/MzExP06.png)

### Design a system that scales to millions of users on AWS

[View exercise and solution](solutions/system_design/scaling_aws/README.md)

![Imgur](images/jj3A5N8.png)

## Задачі по об’єктно-орієнтованому проектуванню на співбесідах, з рішеннями

> Common object-oriented design interview questions with sample discussions, code, and diagrams.
>
> Solutions linked to content in the `solutions/` folder.

>**Note: This section is under development**

| Question | |
|---|---|
| Design a hash map | [Solution](solutions/object_oriented_design/hash_table/hash_map.ipynb)  |
| Design a least recently used cache | [Solution](solutions/object_oriented_design/lru_cache/lru_cache.ipynb)  |
| Design a call center | [Solution](solutions/object_oriented_design/call_center/call_center.ipynb)  |
| Design a deck of cards | [Solution](solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb)  |
| Design a parking lot | [Solution](solutions/object_oriented_design/parking_lot/parking_lot.ipynb)  |
| Design a chat server | [Solution](solutions/object_oriented_design/online_chat/online_chat.ipynb)  |
| Design a circular array | [Contribute](#contributing)  |
| Add an object-oriented design question | [Contribute](#contributing) |

## Проектування програмних систем: початок

Тільки починаєте вивчати проектування?

Спочатку вам потрібно розібратися на базовому рівні із основними поняттями, їх використанням, перевагами та недоліками.

### Крок 1: Перегляньте відео-лекцію по масштабуванню

[Scalability Lecture at Harvard](https://www.youtube.com/watch?v=-W9F__D3oY4)

* Висвітленні теми:
    * Вертикальне масштабування(Vertical scaling)
    * Горизонтальне масштабування(Horizontal scaling)
    * Кешування(Caching)
    * Балансування навантаження(Load balancing)
    * Реплікація(replication) бази даних
    * Розбиття(partitioning) бази даних

### Step 2: Перегляньте статті по масштабуванню

[Scalability](http://www.lecloud.net/tagged/scalability/chrono)

* Висвітленні теми:
    * [Clones](http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
    * [Databases](http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
    * [Caches](http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
    * [Asynchronism](http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism)

### Наступні кроки

Далі ми розглянемо базові компроміси:

* **Продуктивність(Performance)** vs **масштабування(scalability)**
* **Латентність(Latency)** vs **пропускна здатність(throughput)**
* **Доступність(Availability)** vs **узгодженість(consistency)**

Пам'ятайте, що **все є компромісом**.

Далі ми зануримося в більш вузькі розділи, як-от DNS, CDNs та балансувальники навантаження(load balancers). 

## Продуктивність(Performance) vs масштабування(scalability)

Сервіс є **масштабованим**, якщо його **продуктивність** зростає пропорційно до доданих ресурсів. В загальному випадку, під збільшенням продуктивності розуміється можливість опрацьовувати більшу кількість задач, хоча це також може означати можливість опрацьовувати задачі більшого розміру, як у випадку росту набору даних (datasets).<sup><a href=http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html>1</a></sup>

Ще один спосіб розглянути відміність між продуктивностю(performance) та масштабуванням(scalability):

* Якщо у вас проблема з **продуктивністю**, то ваша система буде повільною для одного користувача.
* Якщо у вас проблема з **масштабуванням**, то ваша система буде швидкою для одного користувача, але повільною при високому навантаженні (багато користувачів).

### Джерело(а) та додаткові матеріали

* [A word on scalability](http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html)
* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)

## Латентність(Latency) vs пропускна здатність(throughput)

**Латентність** - це час затрачений на виконання задачі.
**Пропускна здатність** - це кількість таких задач за одиницю часу.

В загальному випадку, наша ціль - це **максимальна пропускна здатність** з **допустимою латентністю**.

### Джерело(а) та додаткові матеріали

* [Understanding latency vs throughput](https://community.cadence.com/cadence_blogs_8/b/sd/archive/2010/09/13/understanding-latency-vs-throughput)

## Доступність(Availability) vs узгодженість(consistency)

### Теорема CAP

<p align="center">
  <img src="http://i.imgur.com/bgLMI2u.png">
  <br/>
  <i><a href=http://robertgreiner.com/2014/08/cap-theorem-revisited>Source: CAP theorem revisited</a></i>
</p>

У розподіленій комп'ютерній системі можна підтримувати тільки дві властивості з наведених:

* **Узгодженість(Consistency)** - Кожне зчитування отримує останні дані або помилку.
* **Доступність(Availability)** - Кожний запит отримує результат, але без гарантії, що це буде остання версія даних.
* **Стійкість до розподілення(Partition Tolerance)** - Система продовжує функціонувати незважаючи на випадкові розділення на ізольовоні секції в результаті мережевих проблем.

*Мережі є ненадійними, тому вам прийдеться підтримувати стійкість до розподілення. Програмний компроміс прийдеться робити між узгодженістю та доступністю.*

#### CP - узгодженність(consistency) і стійкість до розподілення(partition tolerance)

Очікування результату від ізольованого вузла може завершитися помилкою ліміту часу. CP є хорошим рішенням, якщо ваша задача потребує атомарні записи та зчитування.

#### AP - доступність(availability) and стійкість до розподілення(partition tolerance)

Відповідь містить останню версію даних, що доступна на конкретному вузлі, але вона може бути не глобально останньою. Поширення запису може зайняти певний час після того як розподілення усунено.

AP є хорошим вибором, якщо ваша задача потребує [eventual consistency](#eventual-consistency) чи коли система має продовжувати роботу незважаючи на зовнішні помилки.

### Джерело(а) та додаткові матеріали

* [CAP theorem revisited](http://robertgreiner.com/2014/08/cap-theorem-revisited/)
* [A plain english introduction to CAP theorem](http://ksat.me/a-plain-english-introduction-to-cap-theorem/)
* [CAP FAQ](https://github.com/henryr/cap-faq)

## Шаблони узгодженості

Унаслідок наявності декількох копій однакових даних перед нами стоїть вибір між способами синхронізації, які дозволять всім клієнтам мати узгоджену версію даних.  Згадаємо визначення з [CAP theorem](#cap-theorem) - При кожному зчитуванні клієнт отримує дані з найостаннішого запису або помилку.

### Слабка узгодженість(Weak consistency)

Після виконання операції запису, при зчитуванні ми можемо як побачити так і не побачити останні зміни - зважаючи на можливості реплікації системи буде прийнято найоптимальніший для неї підхід, при якому не гарантуватиметься надання актуальних даних.

Наприклад, його використовують в такій системі, як memcached.  Слабку узгодженість найкраще використовувати в системах реального часу, таких як: VoIP, відеочати та мультиплеєрні онлайн ігри.  Наприклад, якщо ви під час телефонного дзвінку втратили зв'язок на кілька секунд і потім він відновився - ви не почуєте того, що було сказано в момент втрати зв'язку.

### Узгодженість в кінцевому рахунку(Eventual consistency)

Після запису, операції зчитування бачитимуть зміни в кінцевому рахунку(зазвичай не більше, ніж після кількох мілісекунд).  Реплікація даних буде здійснена асинхронно.

Такий підхід можна побачити в наступних системах: DNS та email.  Узгодженість в кінцевому рахунку варто застосовувати в високодоступних системах.

### Сильна узгодженість(Strong consistency)

Всі операції зчитування побачать зміни після запису.  Дані будуть скопійовані синхронно.

Цей підхід використовується в файлових системах та СУБД.  Сильна узгодженість використовується в системах з підтримкою транзакцій.

### Джерело(а) і додаткові матеріали

* [Transactions across data centers](http://snarfed.org/transactions_across_datacenters_io.html)

## Шаблони доступності

Існує два основних шаблони для підтримки високої доступності: **аварійне перключення(fail-over)** та **копіювання(replication)**.

### Аварійне переключення (Fail-over)

#### Активний-пасивний (active-passive)

При аварійному переключенні виду "активний-пасивний" сигнали стану(heartbeat) пересилаються між активним та пасивним сервером в режимі очікування.  Якщо сигнал стану перестає поступати на пасивний сервер - він забирає IP адресу активного сервера і продовжує роботу.

Тривалість часу простою визначається тим чи пасивний сервер знаходиться в стані "гарячого" простою або він в "холодному" простої і йому потрібно завантажитись.  Трафік обслуговується лише активним сервером.

Аварійне переключення виду "активний-пасивний" можуть також називати аварійним переключенням типу "ведучий-ведений"(master-slave).

#### Активний-активний (active-active)

При такому варіанті обидва сервери обслуговують трафік і розподіляють навантаження між собою.

Якщо сервери є публічними, то DNS повинен знати публічні IP обох серверів.  Якщо сервери використовуються для внутрішньої взаємодії - логіка додатку повинна знати про усі такі сервери.

Аварійне переключення виду "активний-активний" можуть також називати аварійним переключенням типу "ведучий-ведучий"(master-master).

### Недоліки:

* Аварійне переключення вимагає наявності більшої кількості апаратного забезпечення та додатково ускладнює систему.
* Існує ймовірність втрати даних при відмові активної системи до завершення процесу копіювання нових даних в пасивну.

### Копіювання(Replication)

#### Ведучий-ведений(Master-slave) та (ведучий-ведучий)master-master

Ця тема обговорюється далі в секції [База даних](#база-даних):

* [Master-slave replication](#master-slave-replication)
* [Master-master replication](#master-master-replication)

## Система доменних імен (Domain Name System)

<p align="center">
  <img src="http://i.imgur.com/IOyLj4i.jpg">
  <br/>
  <i><a href=http://www.slideshare.net/srikrupa5/dns-security-presentation-issa>Source: DNS security presentation</a></i>
</p>

Система доменних імен(DNS) конвертує доменне ім'я (наприклад www.example.com) в IP адресу.

DNS представляє собою ієрархічну систему з кількома впливовими сервервами на найвищому рівні.  Ваш роутер або інтернет провайдер надає інформацію про DNS сервер(и) з якими потрібно зв'язуватись під час пошуку IP адреси.  DNS сервери низького рівня кешують мапінги(відображення), які можуть стати застарілими через затримки їх розповсюдження в DNS.  Результати пошуку в DNS можуть також бути закешовані (cached) вашим браузером або операційною системою протягом певного періоду часу, який визначений [time to live (TTL)](https://en.wikipedia.org/wiki/Time_to_live).

* **NS запис (name server)** - Визначає DNS сервери для вашого домену/піддомену.
* **MX запис (mail exchange)** - Визначає поштові сервери для прийому повідомлень.
* **A запис (address)** - Вказує IP адресу для імені веб сайту.
* **CNAME (canonical)** - Вказує ім'я для іншого імені веб сайту або `CNAME` (example.com на www.example.com) або до `A` запису.

Такі сервіси як [CloudFlare](https://www.cloudflare.com/dns/) і [Route 53](https://aws.amazon.com/route53/) надають керовані DNS сервіси.  Деякі DNS сервіси можуть направляти трафік використовуючи кілька наступних методів:

* [Weighted round robin](http://g33kinfo.com/info/archives/2657)
    * Запобігає обробку трафіку серверами, які знаходяться на технічному обслуговуванні
    * Балансує трафік залежно від розміру кластеру
    * A/B тестування
* Базований на затримці мережі
* Базований на геопозиції

### Недоліки: DNS

* Використання DNS серверу додає невелику затримку, проте вона може бути усунута за допомогою кешування, яке було описане вище.
* Управління DNS сервером може бути складним і зазвичай здійснюється [governments, ISPs, and large companies](http://superuser.com/questions/472695/who-controls-the-dns-servers/472729).
* DNS сервіси часто перебувають під [DDoS attack](http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/), preventing users from accessing websites such as Twitter without knowing Twitter's IP address(es).

### Джерело(а) і додаткові матеріали

* [DNS architecture](https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx)
* [Wikipedia](https://en.wikipedia.org/wiki/Domain_Name_System)
* [DNS articles](https://support.dnsimple.com/categories/dns/)

## Мережа доставки контенту(Content delivery network)

<p align="center">
  <img src="http://i.imgur.com/h9TAuGI.jpg">
  <br/>
  <i><a href=https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/>Source: Why use a CDN</a></i>
</p>

Мережа доставки контенту (CDN) - це географічно розподілена мережа проксі-серверів для доставки контенту із вузлів, що знаходяться найближче до користувача. В загальному випадку використовується для статичних файлів, як-от HTML/CSS/JS, фото та відео, хоча деякі CDN, наприклад CloudFront від Amazon, підтримують і динамічний контент. Веб-сайт за допомогою DNS вкаже з якого серверу завантажувати контент.

Використання CDN'ів може істотно підвищити продуктивність двома способами:

* Користувачі отримують контент із дата центрів, що поблизу
* Ваші сервери не мають обробляти запити, що виконують CDN'и

### Push CDN'и

Push CDN'и отримують новий контент як тільки появляються зміни на вашому сервері. Вам потрібно надавати контент, завантажуючи його напряму в CDN, і змінювати посилання, так щоб вони вказували на CDN. Ви можете налаштовувати, коли видаляти контент і коли обновляти. Контент завантажувається тільки, коли він новий або зміненний, таким чином мінімізуючи трафік, але максимізуючи пам'ять.

Веб-сайти з малим об'ємом трафіку чи з контентом, що рідко змінюється, працюють добре із push CDN'ами. Контент завантажується в CDN`и одноразово, а не періодично по таймеру.

### Pull CDN'и

Pull CDN'и завантажують новий контент з вашого сервера, коли перший користувач його запросить. Ви залишаєте контент на вашому сервері і переписуєте посилання так щоб вони вказували на CDN. Це призводить до більш повільного запиту, поки вміст не буде закешовано на CDN.

[time-to-live (TTL)](https://en.wikipedia.org/wiki/Time_to_live) задає як довго контент зберігатиметься у кеші.  Pull CDN'и мінімізують об'єм використаної пам'яті CDN'у, але можуть призвести до лишнього трафіку, коли файли повторно завантажуються із сервера до того як їх було змінено.
Pull CDN`и добре працюють з високонавантаженими веб-сайтами, тому що трафік розподіляється більш рівномірно і тільки нещодавно запитаний контент зберігається на CDN.

### Недолік(и):

* Вартісь CDN може бути істотною залежно від трафіку, проте потрібно також враховувати скільки коштуватиме опрацювання запитів без CDN.
* Контент в CDN може бути застарілим, якщо його обновили до того як завершився термін дії(TTL).
* Потрібно змінити посилання на статичні файли так, щоб вони вказували на CDN.

### Джерело(а) і додаткові матеріали

* [Globally distributed content delivery](https://figshare.com/articles/Globally_distributed_content_delivery/6605972)
* [The differences between push and pull CDNs](http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/)
* [Wikipedia](https://en.wikipedia.org/wiki/Content_delivery_network)

## Балансувальник навантаження (Load balancer)

<p align="center">
  <img src="http://i.imgur.com/h81n9iK.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>
</p>

Балансувальники навантаження розподіляють клієнтські запити до обчислювальних ресурсів, як-от: сервери застосунків (application servers) та бази даних (databases). В кожному випадку балансувальник навантаження повертає результат з обчислювального ресурсу відповідному клієнту. Балансувальники навантаження ефективні для:

* Запобігання надходження запитів до серверів із проблемами
* Запобігання перевантаження ресурсів
* Допомоги в усуненні єдиної точки відмови

Балансувальники навантаження можуть бути реалізовані за допомогою апаратних засобів (дорого) або програмного забезпечення такого як HAProxy.

Додаткові переваги:

* **Припинення SSL (SSL termination)** - Розшифровуються вхідні запити та шифруються відповіді серверів. Таким чином сервери не повинні виконувати ці, потенційно затратні, операції.
* Усунення необхідності встановлення [X.509 certificates](https://en.wikipedia.org/wiki/X.509) на кожен сервер.
* **Постійність сесії (Session persistence)** - Видаються кукі та направляються клієнтські запити до того ж самого сервера кожного разу, за умови, якщо веб-застосунок не відстежує сесії смостійно.

Для того, щоб захиститися від збоїв, часто встановлюють декілька балансувальників навантаження в [active-passive](#active-passive) або [active-active](#active-active) режимі.

Балансувальники навантаження можуть направляти трафік різними способами:

* Використання випадкового сервера
* Використання найменш навантаженного сервера
* Використання сервера на основі сесії/кукі
* [Round robin or weighted round robin](http://g33kinfo.com/info/archives/2657)
* [4 мережевого рівня] (#layer-4-load-balancing)
* [7 мережевого рівня] (#layer-7-load-balancing)

### Балансувальники навантаження 4 мережевого рівня 

Балансувальники навантаження 4 рівня використовують інформацію з [transport layer](#communication) для визначення того як розподіляти запити.  Зазвичай для цього використовується IP адрес відправника та отримувача і портів в заголовку, проте не використовує вміст пакету.  Такі балансувальники навантаження направляють мережеві пакети як до так і від сервера вищого рівня, здійснюючи [Network Address Translation (NAT)](https://www.nginx.com/resources/glossary/layer-4-load-balancing/).

### Балансувальники навантаження 7 мережевого рівня 

Балансувальники навантаження 7 мережевого рівня  використовують інформацію з [application layer](#communication) для визначення того як розподіляти запити.  Зазвичай цей процес залучає використання вмісту заголовку, повідомлення та кукі(cookies). Такі балансувальники навантаження спочатку зупиняють мережевий трафік, потім читають повідомлення і здійснюють рішення щодо балансування навантаження, і після цього відкривають з'єднання до обраного сервера.  Наприклад, балансувальник 7 рівня може направляти відео трафік до серверів котрі його хостять під час спрямування більш чутливого(пріорітетного) трафіку користувачів, який відповідає за білінг, до більш безпечних серверів.

За рахунок гнучкості, балансувальники навантажження 4 рівня потребують менше часу і обчислювальних ресурсів, ніж балансувальники 7 рівня, хоча їх вклад в продуктивність може бути мінімальним на сучасному апаратному забезпеченні загального призначення.

### Горизонтальне масштабування

Балансувальники навантаження можуть також допомогти з горизонтальним масштабуванням, покращуючи продуктивність та доступність.  Масштабування шляхом використання апаратного призначення загального користування є більш ефективним з точки зору вартості і в результаті надає більшу доступність ніж масштабування одного сервера на більш дорогому апаратному забезпеченні(**Vertical Scaling**).  Також простіше найняти талановитого працівника, працюючого з апаратним забезпеченням загального призначення, аніж спеціаліста в корпоративних системах.

#### Недолік(и): горизонтальне масштабування

* Горизонтальне масштабування вводить складність і залучає клонування серверів
    * Сервери не мають зберігати стан: вони не повинні містити будь-які дані, пов'язані з користувачами (наприклад сесії або картинки профіля)
    * Сесії можуть зберігатись в централізованому сховищі даних, такому як [база даних](#база-даних) (SQL, NoSQL) або стійкому [cache](#cache) (Redis, Memcached)
* Сервери нижчого порядку(кеші та бази даних) повинні обробляти тим більше одночасних з'єднань чим більше масштабуються сервери вищого порядку

### Недолік(и): балансувальник навантаження

* Балансувальник навантаження може стати слабким місцем з точки зору продуктивності якщо він не має достатньо ресурсів або зконфігурований неправильно.
* Впровадження балансувальника навантаження задля ліквідації одиничних точок падіння системи призводить до росту її складності.
* Один балансувальник навантаження є одиничною точкою відмови, проте впровадження кількох таких балансувальників підвищує складність системи.

### Джерело(а) і додаткові матеріали

* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Scalability](http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones)
* [Wikipedia](https://en.wikipedia.org/wiki/Load_balancing_(computing))
* [Layer 4 load balancing](https://www.nginx.com/resources/glossary/layer-4-load-balancing/)
* [Layer 7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)
* [ELB listener config](http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html)

## Зворотній проксі(Reverse proxy)

<p align="center">
  <img src="http://i.imgur.com/n41Azff.png">
  <br/>
  <i><a href=https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg>Source: Wikipedia</a></i>
  <br/>
</p>

Зворотній проксі - це веб-сервер, що надає уніфікований публічний інферфейс до групи внутрішніх серверів. Клієнські запити ретранслюються на підходящий внутрішній сервер, а результат повертає клієнту проксі сервер.

Додаткові переваги:

* **Підвищена безпека** - Приховування інформації про внутрішні сервери, блокування IP адрес, обмеження кількості з'єднань для одного корисувача 
* **Підвищена масштабованість та гнучкість** - Клієнти бачать тільки IP адрес зворотнього проксі, що дозволяє масштабувати внутрішні сервери чи міняти їх конфігурацію
* **Припинення SSL(SSL termination)** - Розшифровуються вхідні запити та шифруються відповіді серверів. Таким чином сервери не повинні виконувати ці, потенційно затратні, операції
	* Усунення необхідності встановлення [X.509 certificates](https://		en.wikipedia.org/wiki/X.509) на кожен сервер
* **Стиснення(Compression)** - Стискаються відповіді серверів
* **Кешування** - Повертається результат для закешованих запитів
* **Статичний контент** - Надається статичний контент
    * HTML/CSS/JS
    * Photos
    * Videos
    * Etc

### Балансувальник навантаження(Load balancer) vs зворотній проксі(reverse proxy)

* Балансувальник навантаження корисний, коли у вас є кілька серверів. Часто ці сервери виконують однакову функцію.
* Зворотній проксі може бути корисний навіть з одним сервером, надаючи переваги описані у попередній секції.
* Такі рішення як-от NGINX та HAProxy підтримують зворотній проксі 7 рівня та балансування навантаження.

### Недолік(и): зворотній проксі

* Використання зворотнього проксі збільшує складність.
* Один зворотній проксі - одна точка відмови, декілька - ще більше збільшення складності (ie a [failover](https://en.wikipedia.org/wiki/Failover)).

### Джерело(а) і додаткові матеріали

* [Reverse proxy vs load balancer](https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/)
* [NGINX architecture](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
* [HAProxy architecture guide](http://www.haproxy.org/download/1.2/doc/architecture.txt)
* [Wikipedia](https://en.wikipedia.org/wiki/Reverse_proxy)

## Прикладний рівень

<p align="center">
  <img src="http://i.imgur.com/yB5SYwm.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>
</p>

Відокремлення веб рівня від прикладного(його також називають платформовим) дозволяє вам масштабуватись та незалежно конфігурувати обидва рівні. Для додавання нового API необхідно додавати нові сервери додатків без необхідності додавання веб серверів. **Принцип єдиного обов'язку** пропагує маленькі та автономні сервіси, котрі працюють разом.  Він дозволяє невеликим командам з малими сервісами більш агресивно планувати швидкий розвиток.

Також працівники(ЕОМ) на прикладному рівні допомагають підтримувати [asynchronism](#asynchronism).

### Мікросервіси

З питанням прикладного рівня пов'язані [microservices](https://en.wikipedia.org/wiki/Microservices), які можуть бути описані як набір незалежно розгортуваних, малих, модульних сервісів.  Кожен сервіс виконується в унікальному процесі і спілкується через добре визначений, легкий механізм задля обслуговування цілі бізнесу. <sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>

Для прикладу, Pinterest, міг би мати наступні мікросервіси: профілю користувача, послідовника, стрічки новин, пошуку, завантаження фото, та інші.

### Виявлення сервісів

Такі системи, як [Consul](https://www.consul.io/docs/index.html), [Etcd](https://coreos.com/etcd/docs/latest), та [Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) можуть допомогти сервісам находити один одного шляхом відстеження зареєстрованих імен, адрес та портів.  [Health checks](https://www.consul.io/intro/getting-started/checks.html) допомагають верифікувати цілісність сервісу і часто виконуються з використанням [HTTP](#hypertext-transfer-protocol-http) ендпойнтів.  Consul та Etcd мають вбудоване [key-value store](#key-value-store), яке може бути корисним для зберігання конфігурації та інших спільних даних.

### Недолік(и): прикладний рівень

* Додавання прикладого рівня з слабо зв'язаними сервісами вимагає іншого підходу з архітектурної, операційної та процесової точки зору (порівняно з монолітною системою).
* Мікросервіси можуть збільшувати складність розгортання та обслуговування серверів.

### Джерело(а) і додаткові матеріали

* [Intro to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale)
* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Service oriented architecture](https://en.wikipedia.org/wiki/Service-oriented_architecture)
* [Introduction to Zookeeper](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper)
* [Here's what you need to know about building microservices](https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/)

## База даних

<p align="center">
  <img src="images/Xkm5CXz.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Джерело: Масштабування до перших 10 мільйонів користувачів</a></i>
</p>

### Система управління реляційними базами даних (RDBMS)

SQL як реляційна база даних - це дані організовані у таблиці.

**ACID** - це властивості [транзакцій](https://uk.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D1%96%D1%8F_(%D0%B1%D0%B0%D0%B7%D0%B8_%D0%B4%D0%B0%D0%BD%D0%B8%D1%85)) в реляційній базі даних.

* **Атомарність (Atomicity)** - це одна з властивостей транзакцій, яка гарантує, що кожна транзакція буде виконана або не буде виконана взагалі.
* **Узгодженість (Consistency)** - це властивість, яка гарантує, що база даних завжди буде знаходитись в правильному стані, незалежно від того, чи виконувалась транзакція, чи сталась якась помилка.
* **Ізоляція (Isolation)** - це властивість, яка гарантує що одночасне виконання транзакцій має такі ж результати, як якщо б транзакції виконувалися послідовно.
* **Стійкість (Durability)** - це властивість, яка гарантує, що після успішного завершення транзакції її зміни залишаться в базі даних незалежно від того, що станеться далі, включаючи аварійне завершення системи, збій жорсткого диска або відключення електропостачання.

Існує багато методів маштубування реляційної бази даних: **master-slave replication**, **master-master replication**, **federation**, **sharding**, **denormalization**, і **SQL tuning**.

#### Master-slave replication

Мастер(master) виконує операції читання та запис, реплікуючи записи на один або більше слейвів(slaves), які можуть виконувати тільки операції читання. Слейви також можуть реплікувати дані на додаткові слейви у вигляді дерева. Якщо мастер вийде з ладу, система може продовжувати працювати в режимі читання, до тих пір поки слейв не буде підвищено до мастера, або не буде створено нового мастера 

<p align="center">
  <img src="images/C9ioGtn.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

##### Недоліки: master-slave replication

* Для підвищення слейва до рівня мастера потрібна додаткова логіка.
* Дивіться [Недоліки: реплікація](#Недоліки-replication), щоб ознайомитись з проблемами, пов'язаними з **обома** типами реплікації - мастер-слейв і мастер-мастер.

#### Master-master replication

Обидва майстра виконують операції читання і запису і обмінюються один з одним записами. Якщо будь який мастер виходить з ладу, система може продовжувати працювати з читанням і записом.

<p align="center">
  <img src="images/krAHLGg.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

##### Недоліки: master-master replication

* Вам потрібен балансувальник навантаження або вам потрібно внести зміни до логіки вашого додатка, щоб визначити, куди записувати.
* Більшість систем мастер-мастер або слабко узгоджені (порушують ACID), або мають підвищену затримку запису через синхронізацію.
* Розв'язання конфліктів стає більш важливим зі збільшенням кількості вузлів запису та зі збільшенням затримки.
* Дивіться [Недоліки: реплікація](#Недоліки-replication), щоб ознайомитись з проблемами, пов'язаними з **обома** типами реплікації - мастер-слейв і мастер-мастер.

##### Недоліки: replication

* Існує потенційна загроза втрати даних, якщо майстер відмовить до того, як будь-які недавно записані дані будуть репліковані на інші вузли.
* Записи відтворюються на читаючих репліках. Якщо є багато записів, то читаючі репліки можуть бути перенавантажені зберіганням записів і не зможуть багато читати.
* Чим більше слейвів, тим більше потрібно реплікувати, що призводить до більшої затримки реплікації.
* У деяких системах запис до майстра може породжувати кілька потоків для паралельного запису, тоді як читаючі репліки підтримують лише послідовний запис з одним потоком.
* Реплікація додає більше апаратних засобів та додаткової складності.

##### Джерела та додаткове читання: replication

* [Масштабованість, доступність, стабільність, підходи](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Multi-master replication](https://uk.wikipedia.org/wiki/Multi-master_replication)

#### Федерація

<p align="center">
  <img src="images/U3qV33e.png">
  <br/>
  <i><a href=https://www.youtube.com/watch?v=kKjm4ehYiMs>Source: Scaling up to your first 10 million users</a></i>
</p>

Федерація (або функціональний розподіл) розбиває бази даних за функціональним принципом. Наприклад, замість однієї монолітної бази даних можна мати три бази даних: **форуми**, **користувачі** та **продукти**, що призводить до меншого трафіку на кожну базу даних та, отже, меншого часу реплікації. Менші бази даних дозволяють зберігати більше даних в оперативній пам'яті, що в свою чергу призводить до більшої кількості попадань до кешу завдяки поліпшеній локальності кешування. Без одного центрального майстра, який би послідовно записував дані, можна записувати паралельно, що підвищує продуктивність.

##### Недоліки: федерація

* Федерація може бути корисною стратегією для масштабування бази даних, але вона може бути неефективною, якщо ваша схема вимагає великих функцій або таблиць, які не можуть бути розбиті на менші.
* Вам потрібно буде оновити логіку свого додатку, щоб визначати, з якої бази даних читати та записувати.
* Об'єднання даних з двох баз даних є більш складним за допомогою [зв'язку серверів](http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers).
* Федерація додає більше апаратного забезпечення та додаткової складності.

##### Джерела та додаткове читання: федерація

* [Масштабування до перших 10 мільйонів користувачів](https://www.youtube.com/watch?v=w95murBkYmU)

#### Шардінг

<p align="center">
  <img src="images/wU8x5Id.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

Шардінк розподіляє дані по різних базах даних таким чином, що кожна база даних може керувати лише підмножиною даних. Наприклад, для бази даних користувачів, зі збільшенням кількості користувачів додаються додаткові шарди (частини бази даних) до кластера.

Подібно до переваг [федерації](#федерація), шардинг призводить до зменшення трафіку читання та запису, меншої кількості реплікації та більшої кількості звернень до кешу. Розмір індексу також зменшено, що загалом покращує продуктивність із швидшими запитами. Якщо один шард вийде з ладу, інші шарди все ще працюватимуть, хоча ви захочете додати певну форму реплікації, щоб уникнути втрати даних. Подібно до федерації, тут немає одного центрального майстра, який серіалізує записи, що дозволяє вам писати паралельно з підвищеною пропускною здатністю.

Загальні способи розділення таблиці користувачів – це є перша літера прізвища користувача, або географічне розташування користувача.

##### Недоліки: шардінг

* Вам потрібно буде оновити логіку програми для роботи з шардами, що може призвести до ускладнення запитів SQL.
* Розподіл даних може стати нерівномірним у шарді. Наприклад, набір активних користувачів на шарді може призвести до збільшення навантаження на цей фрагмент порівняно з іншими.
* Перебалансування додає додаткові складності. Функція шардингу на основі [консистентного хешування](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html) може зменшити обсяг переданих даних.
* Об’єднання даних (JOIN) із кількох шардів є складною задачею.
* Шардинг додає більше апаратного забезпечення та приносить додаткової складності.

##### Джерела та додаткове читання: шардінг

* [Прихід до шардингу](http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html)
* [Архітектура баз даних на основі розбиття на шарди](https://en.wikipedia.org/wiki/Shard_(database_architecture))
* [Консистентне хешування](http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html)

#### Денормалізація

Денормалізація спрямована на покращення швидкодії операцій читання за рахунок зниження швидкості операцій запису. Для уникнення дорогих операцій з'єднань, зайві копії даних записуються в кілька таблиць. Деякі СУБД, такі як [PostgreSQL]((https://en.wikipedia.org/wiki/PostgreSQL)) та Oracle, підтримують матеріалізовані види, які забезпечують зберігання зайвої інформації та підтримку її консистентності між зайвими копіями.

Коли дані розподіляються за допомогою таких методів, як [федерація](#федерація) і [шардінг](#шардінг), об’єднання даних між різними дата-центрами ускладняється. Денормалізація може уникнути необхідності таких складних об’єднань.

У більшості систем кількість операцій читання значно більше операцій запису (100:1 або навіть 1000:1). Операція читання в результаті складного з'єднання даних може бути дуже ресурсоємною і вимагати значного часу, потраченого на операцію з жорстким диском.

##### Недоліки: денормалізація

* Дані дублюються.
* Обмеження можуть допомогти забезпечити синхронізацію зайвих копій інформації, що підвищує складність проектування бази даних.
* База даних, що має денормалізовану структуру та використовується для записів з високою навантаженістю, може працювати гірше, ніж її нормалізована аналогічна структура.

##### Джерела та додаткове читання: денормалізація

* [Денормалізація](https://uk.wikipedia.org/wiki/%D0%94%D0%B5%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%96%D0%B7%D0%B0%D1%86%D1%96%D1%8F)

#### SQL tuning

SQL tuning is a broad topic and many [books](https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&field-keywords=sql+tuning) have been written as reference.

It's important to **benchmark** and **profile** to simulate and uncover bottlenecks.

* **Benchmark** - Simulate high-load situations with tools such as [ab](http://httpd.apache.org/docs/2.2/programs/ab.html).
* **Profile** - Enable tools such as the [slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html) to help track performance issues.

Benchmarking and profiling might point you to the following optimizations.

##### Tighten up the schema

* MySQL dumps to disk in contiguous blocks for fast access.
* Use `CHAR` instead of `VARCHAR` for fixed-length fields.
    * `CHAR` effectively allows for fast, random access, whereas with `VARCHAR`, you must find the end of a string before moving onto the next one.
* Use `TEXT` for large blocks of text such as blog posts.  `TEXT` also allows for boolean searches.  Using a `TEXT` field results in storing a pointer on disk that is used to locate the text block.
* Use `INT` for larger numbers up to 2^32 or 4 billion.
* Use `DECIMAL` for currency to avoid floating point representation errors.
* Avoid storing large `BLOBS`, store the location of where to get the object instead.
* `VARCHAR(255)` is the largest number of characters that can be counted in an 8 bit number, often maximizing the use of a byte in some RDBMS.
* Set the `NOT NULL` constraint where applicable to [improve search performance](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search).

##### Use good indices

* Columns that you are querying (`SELECT`, `GROUP BY`, `ORDER BY`, `JOIN`) could be faster with indices.
* Indices are usually represented as self-balancing [B-tree](https://en.wikipedia.org/wiki/B-tree) that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time.
* Placing an index can keep the data in memory, requiring more space.
* Writes could also be slower since the index also needs to be updated.
* When loading large amounts of data, it might be faster to disable indices, load the data, then rebuild the indices.

##### Avoid expensive joins

* [Денормалізація](#денормалізація) where performance demands it.

##### Partition tables

* Break up a table by putting hot spots in a separate table to help keep it in memory.

##### Tune the query cache

* In some cases, the [query cache](https://dev.mysql.com/doc/refman/5.7/en/query-cache.html) could lead to [performance issues](https://www.percona.com/blog/2016/10/12/mysql-5-7-performance-tuning-immediately-after-installation/).

##### Source(s) and further reading: SQL tuning

* [Tips for optimizing MySQL queries](http://aiddroid.com/10-tips-optimizing-mysql-queries-dont-suck/)
* [Is there a good reason i see VARCHAR(255) used so often?](http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)
* [How do null values affect performance?](http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)
* [Slow query log](http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)

### NoSQL

NoSQL is a collection of data items represented in a **key-value store**, **document-store**, **wide column store**, or a **graph database**.  Data is denormalized, and joins are generally done in the application code.  Most NoSQL stores lack true ACID transactions and favor [eventual consistency](#eventual-consistency).

**BASE** is often used to describe the properties of NoSQL databases.  In comparison with the [CAP Theorem](#cap-theorem), BASE chooses availability over consistency.

* **Basically available** - the system guarantees availability.
* **Soft state** - the state of the system may change over time, even without input.
* **Eventual consistency** - the system will become consistent over a period of time, given that the system doesn't receive input during that period.

In addition to choosing between [SQL or NoSQL](#sql-or-nosql), it is helpful to understand which type of NoSQL database best fits your use case(s).  We'll review **key-value stores**, **document-stores**, **wide column stores**, and **graph databases** in the next section.

#### Key-value store

> Abstraction: hash table

A key-value store generally allows for O(1) reads and writes and is often backed by memory or SSD.  Data stores can maintain keys in [lexicographic order](https://en.wikipedia.org/wiki/Lexicographical_order), allowing efficient retrieval of key ranges.  Key-value stores can allow for storing of metadata with a value.

Key-value stores provide high performance and are often used for simple data models or for rapidly-changing data, such as an in-memory cache layer.  Since they offer only a limited set of operations, complexity is shifted to the application layer if additional operations are needed.

A key-value store is the basis for more complex systems such as a document store, and in some cases, a graph database.

##### Source(s) and further reading: key-value store

* [Key-value database](https://en.wikipedia.org/wiki/Key-value_database)
* [Disadvantages of key-value stores](http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or)
* [Redis architecture](http://qnimate.com/overview-of-redis-architecture/)
* [Memcached architecture](https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/)

#### Document store

> Abstraction: key-value store with documents stored as values

A document store is centered around documents (XML, JSON, binary, etc), where a document stores all information for a given object.  Document stores provide APIs or a query language to query based on the internal structure of the document itself.  *Note, many key-value stores include features for working with a value's metadata, blurring the lines between these two storage types.*

Based on the underlying implementation, documents are organized in either collections, tags, metadata, or directories.  Although documents can be organized or grouped together, documents may have fields that are completely different from each other.

Some document stores like [MongoDB](https://www.mongodb.com/mongodb-architecture) and [CouchDB](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/) also provide a SQL-like language to perform complex queries.  [DynamoDB](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) supports both key-values and documents.

Document stores provide high flexibility and are often used for working with occasionally changing data.

##### Source(s) and further reading: document store

* [Document-oriented database](https://en.wikipedia.org/wiki/Document-oriented_database)
* [MongoDB architecture](https://www.mongodb.com/mongodb-architecture)
* [CouchDB architecture](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)
* [Elasticsearch architecture](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)

#### Wide column store

<p align="center">
  <img src="http://i.imgur.com/n16iOGk.png">
  <br/>
  <i><a href=http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html>Source: SQL & NoSQL, a brief history</a></i>
</p>

> Abstraction: nested map `ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>`

A wide column store's basic unit of data is a column (name/value pair).  A column can be grouped in column families (analogous to a SQL table).  Super column families further group column families.  You can access each column independently with a row key, and columns with the same row key form a row.  Each value contains a timestamp for versioning and for conflict resolution.

Google introduced [Bigtable](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) as the first wide column store, which influenced the open-source [HBase](https://www.mapr.com/blog/in-depth-look-hbase-architecture) often-used in the Hadoop ecosystem, and [Cassandra](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html) from Facebook.  Stores such as BigTable, HBase, and Cassandra maintain keys in lexicographic order, allowing efficient retrieval of selective key ranges.

Wide column stores offer high availability and high scalability.  They are often used for very large data sets.

##### Source(s) and further reading: wide column store

* [SQL & NoSQL, a brief history](http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html)
* [Bigtable architecture](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf)
* [HBase architecture](https://www.mapr.com/blog/in-depth-look-hbase-architecture)
* [Cassandra architecture](http://docs.datastax.com/en/cassandra/3.0/cassandra/architecture/archIntro.html)

#### Graph database

<p align="center">
  <img src="http://i.imgur.com/fNcl65g.png">
  <br/>
  <i><a href=https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png>Source: Graph database</a></i>
</p>

> Abstraction: graph

In a graph database, each node is a record and each arc is a relationship between two nodes.  Graph databases are optimized to represent complex relationships with many foreign keys or many-to-many relationships.

Graphs databases offer high performance for data models with complex relationships, such as a social network.  They are relatively new and are not yet widely-used; it might be more difficult to find development tools and resources.  Many graphs can only be accessed with [REST APIs](#representational-state-transfer-rest).

##### Source(s) and further reading: graph

* [Graph database](https://en.wikipedia.org/wiki/Graph_database)
* [Neo4j](https://neo4j.com/)
* [FlockDB](https://blog.twitter.com/2010/introducing-flockdb)

#### Source(s) and further reading: NoSQL

* [Explanation of base terminology](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)
* [NoSQL databases a survey and decision guidance](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)
* [Scalability](http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
* [Introduction to NoSQL](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [NoSQL patterns](http://horicky.blogspot.com/2009/11/nosql-patterns.html)

### SQL or NoSQL

<p align="center">
  <img src="http://i.imgur.com/wXGqG5f.png">
  <br/>
  <i><a href=https://www.infoq.com/articles/Transition-RDBMS-NoSQL/>Source: Transitioning from RDBMS to NoSQL</a></i>
</p>

Reasons for **SQL**:

* Structured data
* Strict schema
* Relational data
* Need for complex joins
* Transactions
* Clear patterns for scaling
* More established: developers, community, code, tools, etc
* Lookups by index are very fast

Reasons for **NoSQL**:

* Semi-structured data
* Dynamic or flexible schema
* Non-relational data
* No need for complex joins
* Store many TB (or PB) of data
* Very data intensive workload
* Very high throughput for IOPS

Sample data well-suited for NoSQL:

* Rapid ingest of clickstream and log data
* Leaderboard or scoring data
* Temporary data, such as a shopping cart
* Frequently accessed ('hot') tables
* Metadata/lookup tables

##### Source(s) and further reading: SQL or NoSQL

* [Scaling up to your first 10 million users](https://www.youtube.com/watch?v=w95murBkYmU)
* [SQL vs NoSQL differences](https://www.sitepoint.com/sql-vs-nosql-differences/)

## Cache

<p align="center">
  <img src="http://i.imgur.com/Q6z24La.png">
  <br/>
  <i><a href=http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html>Source: Scalable system design patterns</a></i>
</p>

Caching improves page load times and can reduce the load on your servers and databases.  In this model, the dispatcher will first lookup if the request has been made before and try to find the previous result to return, in order to save the actual execution.

Databases often benefit from a uniform distribution of reads and writes across its partitions.  Popular items can skew the distribution, causing bottlenecks.  Putting a cache in front of a database can help absorb uneven loads and spikes in traffic.

### Client caching

Caches can be located on the client side (OS or browser), [server side](#reverse-proxy-web-server), or in a distinct cache layer.

### CDN caching

[CDNs](#content-delivery-network) are considered a type of cache.

### Web server caching

[Reverse proxies](#reverse-proxy-web-server) and caches such as [Varnish](https://www.varnish-cache.org/) can serve static and dynamic content directly.  Web servers can also cache requests, returning responses without having to contact application servers.

### Database caching

Your database usually includes some level of caching in a default configuration, optimized for a generic use case.  Tweaking these settings for specific usage patterns can further boost performance.

### Application caching

In-memory caches such as Memcached and Redis are key-value stores between your application and your data storage.  Since the data is held in RAM, it is much faster than typical databases where data is stored on disk.  RAM is more limited than disk, so [cache invalidation](https://en.wikipedia.org/wiki/Cache_algorithms) algorithms such as [least recently used (LRU)](https://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used) can help invalidate 'cold' entries and keep 'hot' data in RAM.

Redis has the following additional features:

* Persistence option
* Built-in data structures such as sorted sets and lists

There are multiple levels you can cache that fall into two general categories: **database queries** and **objects**:

* Row level
* Query-level
* Fully-formed serializable objects
* Fully-rendered HTML

Generally, you should try to avoid file-based caching, as it makes cloning and auto-scaling more difficult.

### Caching at the database query level

Whenever you query the database, hash the query as a key and store the result to the cache.  This approach suffers from expiration issues:

* Hard to delete a cached result with complex queries
* If one piece of data changes such as a table cell, you need to delete all cached queries that might include the changed cell

### Caching at the object level

See your data as an object, similar to what you do with your application code.  Have your application assemble the dataset from the database into a class instance or a data structure(s):

* Remove the object from cache if its underlying data has changed
* Allows for asynchronous processing: workers assemble objects by consuming the latest cached object

Suggestions of what to cache:

* User sessions
* Fully rendered web pages
* Activity streams
* User graph data

### When to update the cache

Since you can only store a limited amount of data in cache, you'll need to determine which cache update strategy works best for your use case.

#### Cache-aside

<p align="center">
  <img src="http://i.imgur.com/ONjORqk.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>
</p>

The application is responsible for reading and writing from storage.  The cache does not interact with storage directly.  The application does the following:

* Look for entry in cache, resulting in a cache miss
* Load entry from the database
* Add entry to cache
* Return entry

```
def get_user(self, user_id):
    user = cache.get("user.{0}", user_id)
    if user is None:
        user = db.query("SELECT * FROM users WHERE user_id = {0}", user_id)
        if user is not None:
            key = "user.{0}".format(user_id)
            cache.set(key, json.dumps(user))
    return user
```

[Memcached](https://memcached.org/) is generally used in this manner.

Subsequent reads of data added to cache are fast.  Cache-aside is also referred to as lazy loading.  Only requested data is cached, which avoids filling up the cache with data that isn't requested.

##### Disadvantage(s): cache-aside

* Each cache miss results in three trips, which can cause a noticeable delay.
* Data can become stale if it is updated in the database.  This issue is mitigated by setting a time-to-live (TTL) which forces an update of the cache entry, or by using write-through.
* When a node fails, it is replaced by a new, empty node, increasing latency.

#### Write-through

<p align="center">
  <img src="http://i.imgur.com/0vBc0hN.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

The application uses the cache as the main data store, reading and writing data to it, while the cache is responsible for reading and writing to the database:

* Application adds/updates entry in cache
* Cache synchronously writes entry to data store
* Return

Application code:

```
set_user(12345, {"foo":"bar"})
```

Cache code:

```
def set_user(user_id, values):
    user = db.query("UPDATE Users WHERE id = {0}", user_id, values)
    cache.set(user_id, user)
```

Write-through is a slow overall operation due to the write operation, but subsequent reads of just written data are fast.  Users are generally more tolerant of latency when updating data than reading data.  Data in the cache is not stale.

##### Disadvantage(s): write through

* When a new node is created due to failure or scaling, the new node will not cache entries until the entry is updated in the database.  Cache-aside in conjunction with write through can mitigate this issue.
* Most data written might never be read, which can be minimized with a TTL.

#### Write-behind (write-back)

<p align="center">
  <img src="http://i.imgur.com/rgSrvjG.png">
  <br/>
  <i><a href=http://www.slideshare.net/jboner/scalability-availability-stability-patterns/>Source: Scalability, availability, stability, patterns</a></i>
</p>

In write-behind, the application does the following:

* Add/update entry in cache
* Asynchronously write entry to the data store, improving write performance

##### Disadvantage(s): write-behind

* There could be data loss if the cache goes down prior to its contents hitting the data store.
* It is more complex to implement write-behind than it is to implement cache-aside or write-through.

#### Refresh-ahead

<p align="center">
  <img src="http://i.imgur.com/kxtjqgE.png">
  <br/>
  <i><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>Source: From cache to in-memory data grid</a></i>
</p>

You can configure the cache to automatically refresh any recently accessed cache entry prior to its expiration.

Refresh-ahead can result in reduced latency vs read-through if the cache can accurately predict which items are likely to be needed in the future.

##### Disadvantage(s): refresh-ahead

* Not accurately predicting which items are likely to be needed in the future can result in reduced performance than without refresh-ahead.

### Disadvantage(s): cache

* Need to maintain consistency between caches and the source of truth such as the database through [cache invalidation](https://en.wikipedia.org/wiki/Cache_algorithms).
* Cache invalidation is a difficult problem, there is additional complexity associated with when to update the cache.
* Need to make application changes such as adding Redis or memcached.

### Source(s) and further reading

* [From cache to in-memory data grid](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)
* [Scalable system design patterns](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)
* [Introduction to architecting systems for scale](http://lethain.com/introduction-to-architecting-systems-for-scale/)
* [Scalability, availability, stability, patterns](http://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [Scalability](http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
* [AWS ElastiCache strategies](http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html)
* [Wikipedia](https://en.wikipedia.org/wiki/Cache_(computing))

## Asynchronism

<p align="center">
  <img src="http://i.imgur.com/54GYsSx.png">
  <br/>
  <i><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>Source: Intro to architecting systems for scale</a></i>
</p>

Asynchronous workflows help reduce request times for expensive operations that would otherwise be performed in-line.  They can also help by doing time-consuming work in advance, such as periodic aggregation of data.

### Message queues

Message queues receive, hold, and deliver messages.  If an operation is too slow to perform inline, you can use a message queue with the following workflow:

* An application publishes a job to the queue, then notifies the user of job status
* A worker picks up the job from the queue, processes it, then signals the job is complete

The user is not blocked and the job is processed in the background.  During this time, the client might optionally do a small amount of processing to make it seem like the task has completed.  For example, if posting a tweet, the tweet could be instantly posted to your timeline, but it could take some time before your tweet is actually delivered to all of your followers.

**[Redis](https://redis.io/)** is useful as a simple message broker but messages can be lost.

**[RabbitMQ](https://www.rabbitmq.com/)** is popular but requires you to adapt to the 'AMQP' protocol and manage your own nodes.

**[Amazon SQS](https://aws.amazon.com/sqs/)** is hosted but can have high latency and has the possibility of messages being delivered twice.

### Task queues

Tasks queues receive tasks and their related data, runs them, then delivers their results.  They can support scheduling and can be used to run computationally-intensive jobs in the background.

**Celery** has support for scheduling and primarily has python support.

### Back pressure

If queues start to grow significantly, the queue size can become larger than memory, resulting in cache misses, disk reads, and even slower performance.  [Back pressure](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html) can help by limiting the queue size, thereby maintaining a high throughput rate and good response times for jobs already in the queue.  Once the queue fills up, clients get a server busy or HTTP 503 status code to try again later.  Clients can retry the request at a later time, perhaps with [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff).

### Disadvantage(s): asynchronism

* Use cases such as inexpensive calculations and realtime workflows might be better suited for synchronous operations, as introducing queues can add delays and complexity.

### Source(s) and further reading

* [It's all a numbers game](https://www.youtube.com/watch?v=1KRYH75wgy4)
* [Applying back pressure when overloaded](http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)
* [Little's law](https://en.wikipedia.org/wiki/Little%27s_law)
* [What is the difference between a message queue and a task queue?](https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function)

## Communication

<p align="center">
  <img src="http://i.imgur.com/5KeocQs.jpg">
  <br/>
  <i><a href=http://www.escotal.com/osilayer.html>Source: OSI 7 layer model</a></i>
</p>

### Hypertext transfer protocol (HTTP)

HTTP is a method for encoding and transporting data between a client and a server.  It is a request/response protocol: clients issue requests and servers issue responses with relevant content and completion status info about the request.  HTTP is self-contained, allowing requests and responses to flow through many intermediate routers and servers that perform load balancing, caching, encryption, and compression.

A basic HTTP request consists of a verb (method) and a resource (endpoint).  Below are common HTTP verbs:

| Verb | Description | Idempotent* | Safe | Cacheable |
|---|---|---|---|---|
| GET | Reads a resource | Yes | Yes | Yes |
| POST | Creates a resource or trigger a process that handles data | No | No | Yes if response contains freshness info |
| PUT | Creates or replace a resource | Yes | No | No |
| PATCH | Partially updates a resource | No | No | Yes if response contains freshness info |
| DELETE | Deletes a resource | Yes | No | No |

*Can be called many times without different outcomes.

HTTP is an application layer protocol relying on lower-level protocols such as **TCP** and **UDP**.

#### Source(s) and further reading: HTTP

* [What is HTTP?](https://www.nginx.com/resources/glossary/http/)
* [Difference between HTTP and TCP](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)
* [Difference between PUT and PATCH](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)

### Transmission control protocol (TCP)

<p align="center">
  <img src="http://i.imgur.com/JdAsdvG.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>
</p>

TCP is a connection-oriented protocol over an [IP network](https://en.wikipedia.org/wiki/Internet_Protocol).  Connection is established and terminated using a [handshake](https://en.wikipedia.org/wiki/Handshaking).  All packets sent are guaranteed to reach the destination in the original order and without corruption through:

* Sequence numbers and [checksum fields](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation) for each packet
* [Acknowledgement](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)) packets and automatic retransmission

If the sender does not receive a correct response, it will resend the packets.  If there are multiple timeouts, the connection is dropped.  TCP also implements [flow control](https://en.wikipedia.org/wiki/Flow_control_(data)) and [congestion control](https://en.wikipedia.org/wiki/Network_congestion#Congestion_control).  These guarantees cause delays and generally result in less efficient transmission than UDP.

To ensure high throughput, web servers can keep a large number of TCP connections open, resulting in high memory usage.  It can be expensive to have a large number of open connections between web server threads and say, a [memcached](https://memcached.org/) server.  [Connection pooling](https://en.wikipedia.org/wiki/Connection_pool) can help in addition to switching to UDP where applicable.

TCP is useful for applications that require high reliability but are less time critical.  Some examples include web servers, database info, SMTP, FTP, and SSH.

Use TCP over UDP when:

* You need all of the data to arrive intact
* You want to automatically make a best estimate use of the network throughput

### User datagram protocol (UDP)

<p align="center">
  <img src="http://i.imgur.com/yzDrJtA.jpg">
  <br/>
  <i><a href=http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/>Source: How to make a multiplayer game</a></i>
</p>

UDP is connectionless.  Datagrams (analogous to packets) are guaranteed only at the datagram level.  Datagrams might reach their destination out of order or not at all.  UDP does not support congestion control.  Without the guarantees that TCP support, UDP is generally more efficient.

UDP can broadcast, sending datagrams to all devices on the subnet.  This is useful with [DHCP](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol) because the client has not yet received an IP address, thus preventing a way for TCP to stream without the IP address.

UDP is less reliable but works well in real time use cases such as VoIP, video chat, streaming, and realtime multiplayer games.

Use UDP over TCP when:

* You need the lowest latency
* Late data is worse than loss of data
* You want to implement your own error correction

#### Source(s) and further reading: TCP and UDP

* [Networking for game programming](http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/)
* [Key differences between TCP and UDP protocols](http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)
* [Difference between TCP and UDP](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)
* [Transmission control protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
* [User datagram protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol)
* [Scaling memcache at Facebook](http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)

### Remote procedure call (RPC)

<p align="center">
  <img src="http://i.imgur.com/iF4Mkb5.png">
  <br/>
  <i><a href=http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview>Source: Crack the system design interview</a></i>
</p>

In an RPC, a client causes a procedure to execute on a different address space, usually a remote server.  The procedure is coded as if it were a local procedure call, abstracting away the details of how to communicate with the server from the client program.  Remote calls are usually slower and less reliable than local calls so it is helpful to distinguish RPC calls from local calls.  Popular RPC frameworks include [Protobuf](https://developers.google.com/protocol-buffers/), [Thrift](https://thrift.apache.org/), and [Avro](https://avro.apache.org/docs/current/).

RPC is a request-response protocol:

* **Client program** - Calls the client stub procedure.  The parameters are pushed onto the stack like a local procedure call.
* **Client stub procedure** - Marshals (packs) procedure id and arguments into a request message.
* **Client communication module** - OS sends the message from the client to the server.
* **Server communication module** - OS passes the incoming packets to the server stub procedure.
* **Server stub procedure** -  Unmarshalls the results, calls the server procedure matching the procedure id and passes the given arguments.
* The server response repeats the steps above in reverse order.

Sample RPC calls:

```
GET /someoperation?data=anId

POST /anotheroperation
{
  "data":"anId";
  "anotherdata": "another value"
}
```

RPC is focused on exposing behaviors.  RPCs are often used for performance reasons with internal communications, as you can hand-craft native calls to better fit your use cases.

Choose a native library (aka SDK) when:

* You know your target platform.
* You want to control how your "logic" is accessed.
* You want to control how error control happens off your library.
* Performance and end user experience is your primary concern.

HTTP APIs following **REST** tend to be used more often for public APIs.

#### Disadvantage(s): RPC

* RPC clients become tightly coupled to the service implementation.
* A new API must be defined for every new operation or use case.
* It can be difficult to debug RPC.
* You might not be able to leverage existing technologies out of the box.  For example, it might require additional effort to ensure [RPC calls are properly cached](http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/) on caching servers such as [Squid](http://www.squid-cache.org/).

### Representational state transfer (REST)

REST is an architectural style enforcing a client/server model where the client acts on a set of resources managed by the server.  The server provides a representation of resources and actions that can either manipulate or get a new representation of resources.  All communication must be stateless and cacheable.

There are four qualities of a RESTful interface:

* **Identify resources (URI in HTTP)** - use the same URI regardless of any operation.
* **Change with representations (Verbs in HTTP)** - use verbs, headers, and body.
* **Self-descriptive error message (status response in HTTP)** - Use status codes, don't reinvent the wheel.
* **[HATEOAS](http://restcookbook.com/Basics/hateoas/) (HTML interface for HTTP)** - your web service should be fully accessible in a browser.

Sample REST calls:

```
GET /someresources/anId

PUT /someresources/anId
{"anotherdata": "another value"}
```

REST is focused on exposing data.  It minimizes the coupling between client/server and is often used for public HTTP APIs.  REST uses a more generic and uniform method of exposing resources through URIs, [representation through headers](https://github.com/for-GET/know-your-http-well/blob/master/headers.md), and actions through verbs such as GET, POST, PUT, DELETE, and PATCH.  Being stateless, REST is great for horizontal scaling and partitioning.

#### Disadvantage(s): REST

* With REST being focused on exposing data, it might not be a good fit if resources are not naturally organized or accessed in a simple hierarchy.  For example, returning all updated records from the past hour matching a particular set of events is not easily expressed as a path.  With REST, it is likely to be implemented with a combination of URI path, query parameters, and possibly the request body.
* REST typically relies on a few verbs (GET, POST, PUT, DELETE, and PATCH) which sometimes doesn't fit your use case.  For example, moving expired documents to the archive folder might not cleanly fit within these verbs.
* Fetching complicated resources with nested hierarchies requires multiple round trips between the client and server to render single views, e.g. fetching content of a blog entry and the comments on that entry. For mobile applications operating in variable network conditions, these multiple roundtrips are highly undesirable.
* Over time, more fields might be added to an API response and older clients will receive all new data fields, even those that they do not need, as a result, it bloats the payload size and leads to larger latencies.

### RPC and REST calls comparison

| Operation | RPC | REST |
|---|---|---|
| Signup    | **POST** /signup | **POST** /persons |
| Resign    | **POST** /resign<br/>{<br/>"personid": "1234"<br/>} | **DELETE** /persons/1234 |
| Read a person | **GET** /readPerson?personid=1234 | **GET** /persons/1234 |
| Read a person’s items list | **GET** /readUsersItemsList?personid=1234 | **GET** /persons/1234/items |
| Add an item to a person’s items | **POST** /addItemToUsersItemsList<br/>{<br/>"personid": "1234";<br/>"itemid": "456"<br/>} | **POST** /persons/1234/items<br/>{<br/>"itemid": "456"<br/>} |
| Update an item    | **POST** /modifyItem<br/>{<br/>"itemid": "456";<br/>"key": "value"<br/>} | **PUT** /items/456<br/>{<br/>"key": "value"<br/>} |
| Delete an item | **POST** /removeItem<br/>{<br/>"itemid": "456"<br/>} | **DELETE** /items/456 |

<p align="center">
  <i><a href=https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/>Source: Do you really know why you prefer REST over RPC</a></i>
</p>

#### Source(s) and further reading: REST and RPC

* [Do you really know why you prefer REST over RPC](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)
* [When are RPC-ish approaches more appropriate than REST?](http://programmers.stackexchange.com/a/181186)
* [REST vs JSON-RPC](http://stackoverflow.com/questions/15056878/rest-vs-json-rpc)
* [Debunking the myths of RPC and REST](http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/)
* [What are the drawbacks of using REST](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)
* [Crack the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)
* [Thrift](https://code.facebook.com/posts/1468950976659943/)
* [Why REST for internal use and not RPC](http://arstechnica.com/civis/viewtopic.php?t=1190508)

## Security

This section could use some updates.  Consider [contributing](#contributing)!

Security is a broad topic.  Unless you have considerable experience, a security background, or are applying for a position that requires knowledge of security, you probably won't need to know more than the basics:

* Encrypt in transit and at rest.
* Sanitize all user inputs or any input parameters exposed to user to prevent [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) and [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
* Use parameterized queries to prevent SQL injection.
* Use the principle of [least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege).

### Source(s) and further reading

* [Security guide for developers](https://github.com/FallibleInc/security-guide-for-developers)
* [OWASP top ten](https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet)

## Appendix

You'll sometimes be asked to do 'back-of-the-envelope' estimates.  For example, you might need to determine how long it will take to generate 100 image thumbnails from disk or how much memory a data structure will take.  The **Powers of two table** and **Latency numbers every programmer should know** are handy references.

### Powers of two table

```
Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
```

#### Source(s) and further reading

* [Powers of two](https://en.wikipedia.org/wiki/Power_of_two)

### Latency numbers every programmer should know

```
Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
```

Handy metrics based on numbers above:

* Read sequentially from disk at 30 MB/s
* Read sequentially from 1 Gbps Ethernet at 100 MB/s
* Read sequentially from SSD at 1 GB/s
* Read sequentially from main memory at 4 GB/s
* 6-7 world-wide round trips per second
* 2,000 round trips per second within a data center

#### Latency numbers visualized

![](https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67)

#### Source(s) and further reading

* [Latency numbers every programmer should know - 1](https://gist.github.com/jboner/2841832)
* [Latency numbers every programmer should know - 2](https://gist.github.com/hellerbarde/2843375)
* [Designs, lessons, and advice from building large distributed systems](http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf)
* [Software Engineering Advice from Building Large-Scale Distributed Systems](https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf)

### Додаткові задачі по проектуванню на співбесідах

> Common system design interview questions, with links to resources on how to solve each.

| Question | Reference(s) |
|---|---|
| Design a file sync service like Dropbox | [youtube.com](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| Design a search engine like Google | [queue.acm.org](http://queue.acm.org/detail.cfm?id=988407)<br/>[stackexchange.com](http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search)<br/>[ardendertat.com](http://www.ardendertat.com/2012/01/11/implementing-search-engines/)<br>[stanford.edu](http://infolab.stanford.edu/~backrub/google.html) |
| Design a scalable web crawler like Google | [quora.com](https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch) |
| Design Google docs | [code.google.com](https://code.google.com/p/google-mobwrite/)<br/>[neil.fraser.name](https://neil.fraser.name/writing/sync/) |
| Design a key-value store like Redis | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| Design a cache system like Memcached | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Design a recommendation system like Amazon's | [hulu.com](https://web.archive.org/web/20170406065247/http://tech.hulu.com/blog/2011/09/19/recommendation-system.html)<br/>[ijcai13.org](http://ijcai13.org/files/tutorial_slides/td3.pdf) |
| Design a tinyurl system like Bitly | [n00tc0d3r.blogspot.com](http://n00tc0d3r.blogspot.com/) |
| Design a chat app like WhatsApp | [highscalability.com](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html)
| Design a picture sharing system like Instagram | [highscalability.com](http://highscalability.com/flickr-architecture)<br/>[highscalability.com](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html) |
| Design the Facebook news feed function | [quora.com](http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed)<br/>[quora.com](http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed)<br/>[slideshare.net](http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture) |
| Design the Facebook timeline function | [facebook.com](https://www.facebook.com/note.php?note_id=10150468255628920)<br/>[highscalability.com](http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html) |
| Design the Facebook chat function | [erlang-factory.com](http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)<br/>[facebook.com](https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0) |
| Design a graph search function like Facebook's | [facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920)<br/>[facebook.com](https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920) |
| Design a content delivery network like CloudFlare | [figshare.com](https://figshare.com/articles/Globally_distributed_content_delivery/6605972) |
| Design a trending topic system like Twitter's | [michael-noll.com](http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/)<br/>[snikolov .wordpress.com](http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/) |
| Design a random ID generation system | [blog.twitter.com](https://blog.twitter.com/2010/announcing-snowflake)<br/>[github.com](https://github.com/twitter/snowflake/) |
| Return the top k requests during a time interval | [cs.ucsb.edu](https://www.cs.ucsb.edu/sites/cs.ucsb.edu/files/docs/reports/2005-23.pdf)<br/>[wpi.edu](http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf) |
| Design a system that serves data from multiple data centers | [highscalability.com](http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html) |
| Design an online multiplayer card game | [indieflashblog.com](http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html)<br/>[buildnewgames.com](http://buildnewgames.com/real-time-multiplayer/) |
| Design a garbage collection system | [stuffwithstuff.com](http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)<br/>[washington.edu](http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf) |
| Design an API rate limiter | [https://stripe.com/blog/](https://stripe.com/blog/rate-limiters) |
| Add a system design question | [Contribute](#contributing) |

### Real world architectures

> Articles on how real world systems are designed.

<p align="center">
  <img src="http://i.imgur.com/TcUo2fw.png">
  <br/>
  <i><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>Source: Twitter timelines at scale</a></i>
</p>

**Don't focus on nitty gritty details for the following articles, instead:**

* Identify shared principles, common technologies, and patterns within these articles
* Study what problems are solved by each component, where it works, where it doesn't
* Review the lessons learned

|Type | System | Reference(s) |
|---|---|---|
| Data processing | **MapReduce** - Distributed data processing from Google | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf) |
| Data processing | **Spark** - Distributed data processing from Databricks | [slideshare.net](http://www.slideshare.net/AGrishchenko/apache-spark-architecture) |
| Data processing | **Storm** - Distributed data processing from Twitter | [slideshare.net](http://www.slideshare.net/previa/storm-16094009) |
| | | |
| Data store | **Bigtable** - Distributed column-oriented database from Google | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf) |
| Data store | **HBase** - Open source implementation of Bigtable | [slideshare.net](http://www.slideshare.net/alexbaranau/intro-to-hbase) |
| Data store | **Cassandra** - Distributed column-oriented database from Facebook | [slideshare.net](http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666)
| Data store | **DynamoDB** - Document-oriented database from Amazon | [harvard.edu](http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf) |
| Data store | **MongoDB** - Document-oriented database | [slideshare.net](http://www.slideshare.net/mdirolf/introduction-to-mongodb) |
| Data store | **Spanner** - Globally-distributed database from Google | [research.google.com](http://research.google.com/archive/spanner-osdi2012.pdf) |
| Data store | **Memcached** - Distributed memory caching system | [slideshare.net](http://www.slideshare.net/oemebamo/introduction-to-memcached) |
| Data store | **Redis** - Distributed memory caching system with persistence and value types | [slideshare.net](http://www.slideshare.net/dvirsky/introduction-to-redis) |
| | | |
| File system | **Google File System (GFS)** - Distributed file system | [research.google.com](http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf) |
| File system | **Hadoop File System (HDFS)** - Open source implementation of GFS | [apache.org](https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html) |
| | | |
| Misc | **Chubby** - Lock service for loosely-coupled distributed systems from Google | [research.google.com](http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf) |
| Misc | **Dapper** - Distributed systems tracing infrastructure | [research.google.com](http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf)
| Misc | **Kafka** - Pub/sub message queue from LinkedIn | [slideshare.net](http://www.slideshare.net/mumrah/kafka-talk-tri-hug) |
| Misc | **Zookeeper** - Centralized infrastructure and services enabling synchronization | [slideshare.net](http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper) |
| | Add an architecture | [Contribute](#contributing) |

### Company architectures

| Company | Reference(s) |
|---|---|
| Amazon | [Amazon architecture](http://highscalability.com/amazon-architecture) |
| Cinchcast | [Producing 1,500 hours of audio every day](http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html) |
| DataSift | [Realtime datamining At 120,000 tweets per second](http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html) |
| DropBox | [How we've scaled Dropbox](https://www.youtube.com/watch?v=PE4gwstWhmc) |
| ESPN | [Operating At 100,000 duh nuh nuhs per second](http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html) |
| Google | [Google architecture](http://highscalability.com/google-architecture) |
| Instagram | [14 million users, terabytes of photos](http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html)<br/>[What powers Instagram](http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances) |
| Justin.tv | [Justin.Tv's live video broadcasting architecture](http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html) |
| Facebook | [Scaling memcached at Facebook](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf)<br/>[TAO: Facebook’s distributed data store for the social graph](https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf)<br/>[Facebook’s photo storage](https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf)<br/>[How Facebook Live Streams To 800,000 Simultaneous Viewers](http://highscalability.com/blog/2016/6/27/how-facebook-live-streams-to-800000-simultaneous-viewers.html) |
| Flickr | [Flickr architecture](http://highscalability.com/flickr-architecture) |
| Mailbox | [From 0 to one million users in 6 weeks](http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html) |
| Netflix | [A 360 Degree View Of The Entire Netflix Stack](http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html)<br/>[Netflix: What Happens When You Press Play?](http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html) |
| Pinterest | [From 0 To 10s of billions of page views a month](http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html)<br/>[18 million visitors, 10x growth, 12 employees](http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html) |
| Playfish | [50 million monthly users and growing](http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html) |
| PlentyOfFish | [PlentyOfFish architecture](http://highscalability.com/plentyoffish-architecture) |
| Salesforce | [How they handle 1.3 billion transactions a day](http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html) |
| Stack Overflow | [Stack Overflow architecture](http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html) |
| TripAdvisor | [40M visitors, 200M dynamic page views, 30TB data](http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html) |
| Tumblr | [15 billion page views a month](http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html) |
| Twitter | [Making Twitter 10000 percent faster](http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster)<br/>[Storing 250 million tweets a day using MySQL](http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html)<br/>[150M active users, 300K QPS, a 22 MB/S firehose](http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html)<br/>[Timelines at scale](https://www.infoq.com/presentations/Twitter-Timeline-Scalability)<br/>[Big and small data at Twitter](https://www.youtube.com/watch?v=5cKTP36HVgI)<br/>[Operations at Twitter: scaling beyond 100 million users](https://www.youtube.com/watch?v=z8LU0Cj6BOU) |
| Uber | [How Uber scales their real-time market platform](http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html)<br/>[Lessons Learned From Scaling Uber To 2000 Engineers, 1000 Services, And 8000 Git Repositories](http://highscalability.com/blog/2016/10/12/lessons-learned-from-scaling-uber-to-2000-engineers-1000-ser.html) |
| WhatsApp | [The WhatsApp architecture Facebook bought for $19 billion](http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html) |
| YouTube | [YouTube scalability](https://www.youtube.com/watch?v=w5WVu624fY8)<br/>[YouTube architecture](http://highscalability.com/youtube-architecture) |

### Company engineering blogs

> Architectures for companies you are interviewing with.
>
> Questions you encounter might be from the same domain.

* [Airbnb Engineering](http://nerds.airbnb.com/)
* [Atlassian Developers](https://developer.atlassian.com/blog/)
* [AWS Blog](https://aws.amazon.com/blogs/aws/)
* [Bitly Engineering Blog](http://word.bitly.com/)
* [Box Blogs](https://blog.box.com/blog/category/engineering)
* [Cloudera Developer Blog](http://blog.cloudera.com/)
* [Dropbox Tech Blog](https://tech.dropbox.com/)
* [Engineering at Quora](http://engineering.quora.com/)
* [Ebay Tech Blog](http://www.ebaytechblog.com/)
* [Evernote Tech Blog](https://blog.evernote.com/tech/)
* [Etsy Code as Craft](http://codeascraft.com/)
* [Facebook Engineering](https://www.facebook.com/Engineering)
* [Flickr Code](http://code.flickr.net/)
* [Foursquare Engineering Blog](http://engineering.foursquare.com/)
* [GitHub Engineering Blog](http://githubengineering.com/)
* [Google Research Blog](http://googleresearch.blogspot.com/)
* [Groupon Engineering Blog](https://engineering.groupon.com/)
* [Heroku Engineering Blog](https://engineering.heroku.com/)
* [Hubspot Engineering Blog](http://product.hubspot.com/blog/topic/engineering)
* [High Scalability](http://highscalability.com/)
* [Instagram Engineering](http://instagram-engineering.tumblr.com/)
* [Intel Software Blog](https://software.intel.com/en-us/blogs/)
* [Jane Street Tech Blog](https://blogs.janestreet.com/category/ocaml/)
* [LinkedIn Engineering](http://engineering.linkedin.com/blog)
* [Microsoft Engineering](https://engineering.microsoft.com/)
* [Microsoft Python Engineering](https://blogs.msdn.microsoft.com/pythonengineering/)
* [Netflix Tech Blog](http://techblog.netflix.com/)
* [Paypal Developer Blog](https://devblog.paypal.com/category/engineering/)
* [Pinterest Engineering Blog](https://medium.com/@Pinterest_Engineering)
* [Quora Engineering](https://engineering.quora.com/)
* [Reddit Blog](http://www.redditblog.com/)
* [Salesforce Engineering Blog](https://developer.salesforce.com/blogs/engineering/)
* [Slack Engineering Blog](https://slack.engineering/)
* [Spotify Labs](https://labs.spotify.com/)
* [Twilio Engineering Blog](http://www.twilio.com/engineering)
* [Twitter Engineering](https://blog.twitter.com/engineering/)
* [Uber Engineering Blog](http://eng.uber.com/)
* [Yahoo Engineering Blog](http://yahooeng.tumblr.com/)
* [Yelp Engineering Blog](http://engineeringblog.yelp.com/)
* [Zynga Engineering Blog](https://www.zynga.com/blogs/engineering)

#### Source(s) and further reading

Looking to add a blog?  To avoid duplicating work, consider adding your company blog to the following repo:

* [kilimchoi/engineering-blogs](https://github.com/kilimchoi/engineering-blogs)

## В розробці

Interested in adding a section or helping complete one in-progress?  [Contribute](#contributing)!

* Distributed computing with MapReduce
* Consistent hashing
* Scatter gather
* [Contribute](#contributing)

## Credits

Credits and sources are provided throughout this repo.

Special thanks to:

* [Hired in tech](http://www.hiredintech.com/system-design/the-system-design-process/)
* [Cracking the coding interview](https://www.amazon.com/dp/0984782850/)
* [High scalability](http://highscalability.com/)
* [checkcheckzz/system-design-interview](https://github.com/checkcheckzz/system-design-interview)
* [shashank88/system_design](https://github.com/shashank88/system_design)
* [mmcgrana/services-engineering](https://github.com/mmcgrana/services-engineering)
* [System design cheat sheet](https://gist.github.com/vasanthk/485d1c25737e8e72759f)
* [A distributed systems reading list](http://dancres.github.io/Pages/)
* [Cracking the system design interview](http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview)

## Contact info

Feel free to contact me to discuss any issues, questions, or comments.

My contact info can be found on my [GitHub page](https://github.com/donnemartin).

## License

*I am providing code and resources in this repository to you under an open source license.  Because this is my personal repository, the license you receive to my code and resources is from me and not my employer (Facebook).*

    Copyright 2017 Donne Martin

    Creative Commons Attribution 4.0 International License (CC BY 4.0)

    http://creativecommons.org/licenses/by/4.0/
	